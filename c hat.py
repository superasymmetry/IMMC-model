import random
import pandas as pd
import math
import copy

class Scheduler:
    '''
    x - distance travelled
    weights - weightings of each factor
    p_num - the number of people on each team
    Random teams are generated by randomly shuffling the array and then taking groups of 4.
    get_distances - calculates the distances for each team needed to travel to the center.
    get_neighbor - makes one small change to the current state.
    '''
    def __init__(self, p_num):
        self.teams = [i for i in range(20)]  # team IDs 0 to 19
        self.p_num = p_num
        # self.weight = [0.25,0.25,0.25,0.25]  # arbitrary weightings
        self.weight = [9.400975910543956e-05, 0.0007270963779412096, 0.0004937655713447342, 0.9986851282916086]
        # team coordinates (tuples)
        self.team_locations = [  # Oceania
            (-25.274398, 133.775136), # Australia
            (37.09024, -95.712891),   # USA
            (23.634501, -102.552784), # Mexico
            # Central America
            (9.748917, -83.753428),   # Costa Rica
            (8.537981, -80.782127),   # Panama
            # South America
            (-38.416097, -63.616672), # Argentina
            (-14.235004, -51.92528),  # Brazil
            (-32.522779, -55.765835), # Uruguay
            (4.570868, -74.297333),   # Colombia
            # Europe
            (46.603354, 1.888334),    # France
            (40.463667, -3.74922),    # Spain
            (52.132633, 5.291266),    # Netherlands
            (55.378051, -3.435973),   # England
            (39.399872, -8.224454),   # Portugal
            # Africa
            (31.791702, -7.09262),    # Morocco
            (14.497401, -14.452362),  # Senegal
            # Asia
            (36.204824, 138.252924),  # Japan
            (14.058324, 108.277199),  # Vietnam
            (32.427908, 53.688046),   # Iran
            (38.963745, 35.243322)    # Turkey
        ]
        self.distance_by_team = []
        # groupings that Mars did
        self.rounds = [
            [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19]],
            [[0,5,10,15],[4,9,14,19],[8,13,18,3],[12,17,2,7],[16,1,6,11]],
            [[0,9,18,7],[4,13,2,11],[8,17,6,15],[12,1,10,19],[16,5,14,3]],
            [[0,13,6,19],[4,17,10,3],[8,1,14,7],[12,5,18,11],[16,9,2,15]],
            [[0,17,14,11],[4,1,18,15],[8,5,2,19],[12,9,6,3],[16,13,10,7]],
            [[0,4,8,12,16],[1,5,9,13,17],[2,6,10,14,18],[3,7,11,15,19]]
            ]

        # airport dataset
        venues = pd.read_csv("venues.csv", header=None)
        self.venue_locations = list(zip(venues[0], venues[1]))

    # Modified objective function that takes an ordering as input.
    def objective(self, ordering):
        total_score = 0
        # For each round in self.rounds
        for rd in self.rounds:
            for group in rd:
                # group contains indices into the ordering
                # Use ordering to determine the actual team IDs.
                teams_in_group = [ordering[idx] for idx in group]
                # Find the midpoint (average) of team locations in this group.
                median_x = sum(self.team_locations[team][0] for team in teams_in_group) / len(teams_in_group)
                median_y = sum(self.team_locations[team][1] for team in teams_in_group) / len(teams_in_group)
                # Sum Euclidean distances from each team's location to the midpoint.
                total_score += sum(
                    (self.fairness(self.team_locations[team][0], self.team_locations[team][1], median_x, median_y))*self.weight[0]
                     +self.cost_fairness(self.team_locations[team][0], self.team_locations[team][1])*self.weight[1]
                     +self.travelcost(self.team_locations[team][0], self.team_locations[team][1], median_x, median_y, 3)*self.weight[2]
                     +self.sus(self.team_locations[team][0], self.team_locations[team][1], median_x, median_y, 3)*self.weight[3]
                    for team in teams_in_group
                )
                
        return total_score
    
    def fairness(self, lat1, long1, lat2, long2):
        return ((lat1-lat2)**2+(long1-long2)**2)

    def cost_fairness(self, lat1, lat2):
        return ((lat1-lat2)**2)
    
    def travelcost(self, lat1, long1, lat2, long2, nights):
        # Compute great-circle distance in km:
        dist = 6371 * math.acos(
                math.sin(math.radians(lat1)) * math.sin(math.radians(lat2)) +
                math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *
                math.cos(math.radians(long2) - math.radians(long1))
            )
        # Use an exponential or power function to amplify differences:
        amplified = math.pow(dist, 1.1)  # exponent > 1 amplifies differences
        return 65.87 + 0.23 * amplified + nights * 100

    def sus(self, lat1, long1, lat2, long2, nights):
        dist =  6371 * math.acos(
                math.sin(math.radians(lat1)) * math.sin(math.radians(lat2)) +
                math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *
                math.cos(math.radians(long2) - math.radians(long1))
            )
        return dist/1000*(0.8)**(2*math.log(dist))+nights/3

    def get_neighbor(self, ordering, step_size):
        neighbor = ordering.copy()
        for i in range(step_size):
            t1, t2 = random.sample(range(len(neighbor)), 2)
            neighbor[t1], neighbor[t2] = neighbor[t2], neighbor[t1]
        return neighbor

    # Simulated annealing optimization.
    def optimize(self, n_iter, step_size, temp):
        # Initialize with a random ordering.
        random.shuffle(self.teams)
        current = self.teams.copy()
        current_eval = self.objective(current)
        best = current.copy()
        best_eval = current_eval
        scores = [best_eval]

        for i in range(n_iter):
            t = temp / float(i + 1)
            candidate = self.get_neighbor(current, step_size)
            candidate_eval = self.objective(candidate)
            if candidate_eval < current_eval or random.random() < math.exp((current_eval - candidate_eval) / t):
                current, current_eval = candidate, candidate_eval
                if candidate_eval < best_eval:
                    best, best_eval = candidate, candidate_eval
                    scores.append(best_eval)
            print(f"Iteration {i}, Temperature {t:.3f}, Best Evaluation {best_eval:.5f}")
            print("")

        return best, best_eval, scores
    
    def ipf(self, a, b, c, d, tolerance=1e-4, target=[0.25, 0.25, 0.25, 0.25]):
        '''
        a, b, c, d - total scores of the four factors
        tolerance - the error threshold for convergence
        target - desired target proportions for the contributions of the factors
        '''
        weights = self.weight.copy()  # Start with current weights
        while True:
            c_i = [a * weights[0], b * weights[1], c * weights[2], d * weights[3]]
            c_total = sum(c_i)
            p_i = [c_i[i] / c_total for i in range(len(c_i))]

            # Update weights
            weights = [weights[i] * target[i] / p_i[i] for i in range(len(weights))]

            # Normalize the new weights
            denom = sum(weights)
            weights = [w / denom for w in weights]

            # Check convergence (compare p_i to target)
            diff = sum(abs(p_i[i] - target[i]) for i in range(len(target)))
            if diff < tolerance:
                break

        return weights


    def doubleroundrobin(self):
        score = 0
        for i in range(len(self.teams)):
            for j in range(i+1, len(self.teams)):
                score += (s.fairness(self.team_locations[i][0], self.team_locations[i][1], self.team_locations[j][0], self.team_locations[j][1])*self.weight[0]
                        + s.cost_fairness(self.team_locations[i][0], self.team_locations[j][0])*self.weight[1]
                        + s.travelcost(self.team_locations[i][0], self.team_locations[i][1], self.team_locations[j][0], self.team_locations[j][1], 3)*self.weight[2]
                        + s.sus(self.team_locations[i][0], self.team_locations[i][1], self.team_locations[j][0], self.team_locations[j][1], 3)*self.weight[3])
        return score

# Example usage:
s = Scheduler(20)
best, best_cost, scores = s.optimize(500, 1, 1000)
# fair, costfair, sustainability, travelcost = s.fairness(2000),s.cost_fairness(2000),s.sustainability(2000),s.travelcost(2000)

coordinates = s.team_locations.copy()
total_fairness = 0
total_cost_fairness = 0
total_travelcost = 0
total_sus = 0
nights = 3

# Iterate over all pairs of locations
for i in range(len(coordinates)):
    for j in range(i + 1, len(coordinates)):
        lat1, long1 = coordinates[i]
        lat2, long2 = coordinates[j]

        total_fairness += s.fairness(lat1, long1, lat2, long2)
        total_cost_fairness += s.cost_fairness(lat1, lat2)
        total_travelcost += s.travelcost(lat1, long1, lat2, long2, nights)
        total_sus += s.sus(lat1, long1, lat2, long2, nights)

print(total_fairness, total_cost_fairness, total_travelcost, total_sus)

weights = s.ipf(total_fairness, total_cost_fairness, total_travelcost, total_sus)
print(weights)
print("Best ordering:", best)
print("Best cost:", best_cost)

print(f"double round robin: {s.doubleroundrobin()}")