
# someone needs to check the accuracy of these numbers I just put in some arbitrary ones
import random
import math

class Scheduler:
    '''
    x - distance travelled
    weights - weightings of each factor
    p_num - the number of people on each team
    random teams are generated by randomly shuffling the array and then taking groups of 4
    get_distances - calculates the distances for each team needed to travel to the center
    get_neighbor - makes one small change to the current state
    '''
    def __init__(self, teams, p_num):
        # self.teams = teams
        self.teams = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
        self.p_num = p_num
        self.weight = [0.3, 0.3, 0.4] # arbitrary weightings for all the factors - need to change
        # team coordinates
        self.team_locations = [{2, 3}, {4,5}, {5, 6}, {2,3}, {10, 2}, {4,7}, {9,6}, {13,5}, {5,5},{12,10},{13, 1}, {20, 1}, {4,3}, {6,7}, {2,9}, {14, 3}, {12, 3}, {1, 2}, {9, 10}, {13, 2}]
        self.distance_by_team = []

    # objective function
    def objective(self,x):
        return self.fairness(x)*self.weight[0] + self.sustainability(x)*self.weight[1] + self.cost_per_team(x)*self.weight[2]

    def fairness(self,x):
        n = len(self.distance_by_team)
        mean = sum(self.distance_by_team)/n
        var = sum((d-(mean)) for d in self.distance_by_team)/n
        return var

    def sustainability(self,x):
        # strength - automatically discourages any x<49.69 because it will approach infinity (asymptotic)
        return (2.6*x+1000)*(1+135/(x-49.69)) #1000 for takeoff and landing

    def cost_per_team(self,x):
        return (0.1*min(x,18500-x)+100+100*x)*self.p_num

    # ----------------------------------------simulated annealing---------------------------------------------------
    def get_distances(self, groups):
        for i in range(5):
            group = groups[i*5:i*5+5]
            median_x = sum(group[j][0] for j in range len(group))/4
            median_y = sum(group[j][1] for j in range len(group))/4
            distances = [(abs(group[j][0]-median_x))**2+(abs(group[j][1]-median_y))**2 for j in range len(group)]
        return distances
    
    def get_neighbor(self, groups, step_size):
        # swap a team in two randomly selected groups
        for i in range(step_size):
            g1, g2 = random.sample(range(20), 2)
            groups[g1], groups[g2] = groups[g2], groups[g1]
        return groups


    # simulated annealing function
    def optimize(self, n_iter, step_size, temp):
        # initial state
        teams_copy = self.teams[:].copy()
        random.shuffle(teams_copy)
        groups = [teams_copy[i:i+4] for i in range(0, len(teams_copy), 4)] #groups of 4
        best = self.objective()
        distances = self.get_distances(groups)
        best_eval = sum(self.objective(distances[j]) for j in len(distances))
        scores = [best_eval]

        for i in range(n_iter):
            # get distances
            distances = self.get_distances(groups)
            total_cost = sum(self.objective(distances[j]) for j in len(distances))
        
            t = temp / float(i + 1)
            # Generate candidate solution
            candidate = self.get_neighbor(current, step_size)
            candidate_eval = self.objective(candidate)
            # Check if we should keep the new solution
            if candidate_eval < best_eval or random.random() < math.exp((current_eval - candidate_eval) / t):
                current, current_eval = candidate, candidate_eval
                if candidate_eval < best_eval:
                    best, best_eval = candidate, candidate_eval
                    scores.append(best_eval)

            print(f"Iteration {i}, Temperature {t:.3f}, Best Evaluation {best_eval:.5f}")

        return best, best_eval, scores
    
